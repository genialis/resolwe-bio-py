"""Annotate samples in a collection."""

from __future__ import absolute_import, division, print_function, unicode_literals

import logging

from resdk.data_upload.samplesheet import FileExporter, FileImporter

__all__ = ('annotate_samples', 'export_annotation')

logger = logging.getLogger(__name__)


def annotate_samples(collection, samplesheet_source, schema='sample',
                     source_type='local'):
    """Batch-annotate the samples in a collection.

    This method applies annotations to the samples in a collection based on a
    sample annotation spreadsheet. The entries in the spreadsheet and the
    samples in the collection are matched by sample name, and validated for
    upload.

    :param str samplesheet_source: path to a local sample annotation
        spreadsheet, or name of one in the collection, or an existing
        FileImporter object created from an upload
    :param str schema: slug of the descriptor schema to use
    :param bool local_sheet: look for the annotation spreadsheet locally, rather
        than in the collection
    """
    # Extract the information from a sample annotation spreadsheet
    if source_type == 'local':
        samplesheet = FileImporter(samplesheet_source)
    elif source_type == 'upload':
        samplesheet = samplesheet_source

    # TODO: Try to pull the samplesheet as a data object from the collection
    #       once it is possible to upload samplesheets
    # else:
    #     sheet = collection.data.get(name=samplesheet_source,
    #                                 type='data:annotation')
    #     sheet.download()
    #     samplesheet = FileImporter(sheet.files()[0])
    #     err_samples = []

    err_samples = samplesheet.invalid_samples
    missing_samples = []
    sample_count = 0

    def _get_collection_samples(name):
        """Check a collection for a given sample name.

        :param str name: name of the sample(s) to look for
        """
        coll_samples = collection.samples.filter(name=name)
        if not coll_samples:
            missing_samples.append(name)
            logger.warning("Sample '%s' not found.", name)
        return coll_samples

    # Check if any of the invalid samples are also missing from the collection
    for name in err_samples:
        _get_collection_samples(name)

    # Apply each annotation to a sample in the collection
    for sample in samplesheet.sample_list:
        new_samples = _get_collection_samples(sample.name)
        for new in new_samples:
            new.descriptor_schema = schema
            new.descriptor = sample.sample_annotation
            if sample.tag_community():
                new.tags.append(sample.tag_community())
            new.save()
            new.confirm_is_annotated()
            sample_count += 1

            # Apply the reads descriptor to all of the reads associated with
            # the sample
            for reads in new.data.filter(type='data:reads'):
                reads.descriptor_schema = 'reads'
                reads.descriptor = sample.reads_annotation
                reads.save()

    # Report annotation results and errors.
    logger.info("\nAnnotated %s samples.", sample_count)
    if err_samples:
        logger.error(
            "\nInvalid annotations were provided for the following samples: %s."
            "\nPlease fill in all bolded columns of the template "
            "generated by the `export_annotation` method of"
            " your collection.",
            ', '.join(err_samples)
        )
    if missing_samples:
        logger.error(
            "\nThe following samples are missing from the collection:"
            " %s. \nPlease check the names.",
            ', '.join(missing_samples)
        )


def export_annotation(collection=None, path=None):
    """Download a sample annotation spreadsheet based on the collection.

    Populate this template with sample annotation data, and re-import it using
    ``Collection.annotate``.

    :param str path: path to save the annotation spreadsheet template
    """
    if collection:
        samples = collection.samples
    else:
        samples = []
    samplesheet = FileExporter(path, samples)
    samplesheet.export_template()
